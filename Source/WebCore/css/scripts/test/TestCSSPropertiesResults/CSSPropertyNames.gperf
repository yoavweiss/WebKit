%{
// This file is automatically generated from CSSProperties.json by the process-css-properties.py script. Do not edit it.

#include "config.h"
#include "CSSPropertyNames.h"

#include "BoxSides.h"
#include "CSSProperty.h"
#include "Settings.h"
#include <string.h>
#include <wtf/ASCIICType.h>
#include <wtf/Hasher.h>
#include <wtf/text/AtomString.h>
#include <wtf/text/TextStream.h>


IGNORE_WARNINGS_BEGIN("implicit-fallthrough")
WTF_ALLOW_UNSAFE_BUFFER_USAGE_BEGIN

// Older versions of gperf like to use the `register` keyword.
#define register

namespace WebCore {

static_assert(cssPropertyIDEnumValueCount <= (std::numeric_limits<uint16_t>::max() + 1), "CSSPropertyID should fit into uint16_t.");

const std::array<CSSPropertyID, 13> computedPropertyIDs {
    CSSPropertyID::CSSPropertyTestAnimationWrapper,
    CSSPropertyID::CSSPropertyTestAnimationWrapperAccelerationAlways,
    CSSPropertyID::CSSPropertyTestAnimationWrapperAccelerationThreadedOnly,
    CSSPropertyID::CSSPropertyTestHighPriority,
    CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalBlock,
    CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalInline,
    CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalHorizontal,
    CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalVertical,
    CSSPropertyID::CSSPropertyTestProperty,
    CSSPropertyID::CSSPropertyTestSettingsOne,
    CSSPropertyID::CSSPropertyTestSinkPriority,
    CSSPropertyID::CSSPropertyTestTopPriority,
    CSSPropertyID::CSSPropertyTestUsingSharedRule,
};

constexpr ASCIILiteral propertyNameStrings[numCSSProperties] = {
    "test-top-priority"_s,
    "test-high-priority"_s,
    "first-test-descriptor-for-first-descriptor"_s,
    "first-test-descriptor-for-second-descriptor"_s,
    "test-animation-wrapper"_s,
    "test-animation-wrapper-acceleration-always"_s,
    "test-animation-wrapper-acceleration-threaded-only"_s,
    "test-property"_s,
    "test-settings-one"_s,
    "test-using-shared-rule"_s,
    "test-sink-priority"_s,
    "test-logical-property-group-logical-block"_s,
    "test-logical-property-group-logical-inline"_s,
    "test-logical-property-group-physical-horizontal"_s,
    "test-logical-property-group-physical-vertical"_s,
    "font"_s,
    "test-shorthand-one"_s,
    "test-shorthand-two"_s,
};

%}
%struct-type
struct CSSPropertyHashTableEntry {
    const char* name;
    uint16_t id;
};
%language=C++
%readonly-tables
%global-table
%7bit
%compare-strncmp
%define class-name CSSPropertyNamesHash
%enum

%%
test-top-priority, CSSPropertyID::CSSPropertyTestTopPriority
test-high-priority, CSSPropertyID::CSSPropertyTestHighPriority
first-test-descriptor-for-first-descriptor, CSSPropertyID::CSSPropertyFirstTestDescriptorForFirstDescriptor
first-test-descriptor-for-second-descriptor, CSSPropertyID::CSSPropertyFirstTestDescriptorForSecondDescriptor
test-animation-wrapper, CSSPropertyID::CSSPropertyTestAnimationWrapper
test-animation-wrapper-acceleration-always, CSSPropertyID::CSSPropertyTestAnimationWrapperAccelerationAlways
test-animation-wrapper-acceleration-threaded-only, CSSPropertyID::CSSPropertyTestAnimationWrapperAccelerationThreadedOnly
test-property, CSSPropertyID::CSSPropertyTestProperty
test-settings-one, CSSPropertyID::CSSPropertyTestSettingsOne
test-using-shared-rule, CSSPropertyID::CSSPropertyTestUsingSharedRule
test-sink-priority, CSSPropertyID::CSSPropertyTestSinkPriority
test-logical-property-group-logical-block, CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalBlock
test-logical-property-group-logical-inline, CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalInline
test-logical-property-group-physical-horizontal, CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalHorizontal
test-logical-property-group-physical-vertical, CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalVertical
font, CSSPropertyID::CSSPropertyFont
test-shorthand-one, CSSPropertyID::CSSPropertyTestShorthandOne
test-shorthand-two, CSSPropertyID::CSSPropertyTestShorthandTwo
%%

CSSPropertyID findCSSProperty(const char* characters, unsigned length)
{
    auto* value = CSSPropertyNamesHash::in_word_set(characters, length);
    return value ? static_cast<CSSPropertyID>(value->id) : CSSPropertyID::CSSPropertyInvalid;
}

ASCIILiteral nameLiteral(CSSPropertyID id)
{
    if (id < firstCSSProperty)
        return { };
    unsigned index = id - firstCSSProperty;
    if (index >= numCSSProperties)
        return { };
    return propertyNameStrings[index];
}

const AtomString& nameString(CSSPropertyID id)
{
    if (id < firstCSSProperty)
        return nullAtom();
    unsigned index = id - firstCSSProperty;
    if (index >= numCSSProperties)
        return nullAtom();

    static NeverDestroyed<std::array<AtomString, numCSSProperties>> atomStrings;
    auto& string = atomStrings.get()[index];
    if (string.isNull())
        string = propertyNameStrings[index];
    return string;
}

String nameForIDL(CSSPropertyID id)
{
    LChar characters[maxCSSPropertyNameLength];
    const char* nameForCSS = nameLiteral(id);
    if (!nameForCSS)
        return emptyString();

    auto* propertyNamePointer = nameForCSS;
    auto* nextCharacter = characters;
    while (char character = *propertyNamePointer++) {
        if (character == '-') {
            char nextCharacter = *propertyNamePointer++;
            if (!nextCharacter)
                break;
            character = (propertyNamePointer - 2 != nameForCSS) ? toASCIIUpper(nextCharacter) : nextCharacter;
        }
        *nextCharacter++ = character;
    }
    return std::span<const LChar> { characters, nextCharacter };
}


bool isInternal(CSSPropertyID id)
{
    switch (id) {
        return true;
    default:
        return false;
    }
}

static bool isExposedNotInvalidAndNotInternal(CSSPropertyID id, const CSSPropertySettings& settings)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyFirstTestDescriptorForFirstDescriptor:
        return settings.cssDescriptorEnabled;
    case CSSPropertyID::CSSPropertyTestSettingsOne:
        return settings.cssSettingsOneEnabled;
    default:
        return true;
    }
}

static bool isExposedNotInvalidAndNotInternal(CSSPropertyID id, const Settings& settings)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyFirstTestDescriptorForFirstDescriptor:
        return settings.cssDescriptorEnabled();
    case CSSPropertyID::CSSPropertyTestSettingsOne:
        return settings.cssSettingsOneEnabled();
    default:
        return true;
    }
}

bool isExposed(CSSPropertyID id, const CSSPropertySettings* settings)
{
    if (id == CSSPropertyID::CSSPropertyInvalid || isInternal(id))
        return false;
    if (!settings)
        return true;
    return isExposedNotInvalidAndNotInternal(id, *settings);
}

bool isExposed(CSSPropertyID id, const CSSPropertySettings& settings)
{
    if (id == CSSPropertyID::CSSPropertyInvalid || isInternal(id))
        return false;
    return isExposedNotInvalidAndNotInternal(id, settings);
}

bool isExposed(CSSPropertyID id, const Settings* settings)
{
    if (id == CSSPropertyID::CSSPropertyInvalid || isInternal(id))
        return false;
    if (!settings)
        return true;
    return isExposedNotInvalidAndNotInternal(id, *settings);
}

bool isExposed(CSSPropertyID id, const Settings& settings)
{
    if (id == CSSPropertyID::CSSPropertyInvalid || isInternal(id))
        return false;
    return isExposedNotInvalidAndNotInternal(id, settings);
}

constexpr bool isInheritedPropertyTable[cssPropertyIDEnumValueCount] = {
    false, // CSSPropertyID::CSSPropertyInvalid
    true , // CSSPropertyID::CSSPropertyCustom
    false, // CSSPropertyID::CSSPropertyTestTopPriority
    false, // CSSPropertyID::CSSPropertyTestHighPriority
    false, // CSSPropertyID::CSSPropertyFirstTestDescriptorForFirstDescriptor
    false, // CSSPropertyID::CSSPropertyFirstTestDescriptorForSecondDescriptor
    false, // CSSPropertyID::CSSPropertyTestAnimationWrapper
    false, // CSSPropertyID::CSSPropertyTestAnimationWrapperAccelerationAlways
    false, // CSSPropertyID::CSSPropertyTestAnimationWrapperAccelerationThreadedOnly
    false, // CSSPropertyID::CSSPropertyTestProperty
    false, // CSSPropertyID::CSSPropertyTestSettingsOne
    false, // CSSPropertyID::CSSPropertyTestUsingSharedRule
    false, // CSSPropertyID::CSSPropertyTestSinkPriority
    false, // CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalBlock
    false, // CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalInline
    false, // CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalHorizontal
    false, // CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalVertical
    false, // CSSPropertyID::CSSPropertyFont
    false, // CSSPropertyID::CSSPropertyTestShorthandOne
    false, // CSSPropertyID::CSSPropertyTestShorthandTwo
};

bool CSSProperty::isInheritedProperty(CSSPropertyID id)
{
    ASSERT(id < cssPropertyIDEnumValueCount);
    ASSERT(id != CSSPropertyID::CSSPropertyInvalid);
    return isInheritedPropertyTable[id];
}

CSSPropertyID cascadeAliasProperty(CSSPropertyID id)
{
    switch (id) {
    default:
        return id;
    }
}

Vector<String> CSSProperty::aliasesForProperty(CSSPropertyID id)
{
    switch (id) {
    default:
        return { };
    }
}

const WTF::BitSet<cssPropertyIDEnumValueCount> CSSProperty::colorProperties = ([]() -> WTF::BitSet<cssPropertyIDEnumValueCount> {
    WTF::BitSet<cssPropertyIDEnumValueCount> result;
    return result;
})();

const WTF::BitSet<cssPropertyIDEnumValueCount> CSSProperty::physicalProperties = ([]() -> WTF::BitSet<cssPropertyIDEnumValueCount> {
    WTF::BitSet<cssPropertyIDEnumValueCount> result;
    result.set(CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalHorizontal);
    result.set(CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalVertical);
    return result;
})();

UChar CSSProperty::listValuedPropertySeparator(CSSPropertyID id)
{
    switch (id) {
    default:
        break;
    }
    return '\0';
}

bool CSSProperty::allowsNumberOrIntegerInput(CSSPropertyID id)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyTestTopPriority:
    case CSSPropertyID::CSSPropertyTestHighPriority:
    case CSSPropertyID::CSSPropertyTestAnimationWrapper:
    case CSSPropertyID::CSSPropertyTestAnimationWrapperAccelerationAlways:
    case CSSPropertyID::CSSPropertyTestAnimationWrapperAccelerationThreadedOnly:
    case CSSPropertyID::CSSPropertyTestProperty:
    case CSSPropertyID::CSSPropertyTestSettingsOne:
    case CSSPropertyID::CSSPropertyTestUsingSharedRule:
    case CSSPropertyID::CSSPropertyTestSinkPriority:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalBlock:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalInline:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalHorizontal:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalVertical:
        return true;
    default:
        return false;
    }
}

bool CSSProperty::disablesNativeAppearance(CSSPropertyID id)
{
    switch (id) {
        return true;
    default:
        return false;
    }
}

bool CSSProperty::isDirectionAwareProperty(CSSPropertyID id)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalBlock:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalInline:
        return true;
    default:
        return false;
    }
}

bool CSSProperty::isTestGroupProperty(CSSPropertyID id)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalBlock:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalInline:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalHorizontal:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalVertical:
    case CSSPropertyID::CSSPropertyTestShorthandOne:
    case CSSPropertyID::CSSPropertyTestShorthandTwo:
        return true;
    default:
        return false;
    }
}

bool CSSProperty::isInLogicalPropertyGroup(CSSPropertyID id)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalBlock:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalInline:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalHorizontal:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalVertical:
        return true;
    default:
        return false;
    }
}

bool CSSProperty::areInSameLogicalPropertyGroupWithDifferentMappingLogic(CSSPropertyID id1, CSSPropertyID id2)
{
    switch (id1) {
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalBlock:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalInline:
        switch (id2) {
        case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalHorizontal:
        case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalVertical:
            return true;
        default:
            return false;
        }
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalHorizontal:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalVertical:
        switch (id2) {
        case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalBlock:
        case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalInline:
            return true;
        default:
            return false;
        }
    default:
        return false;
    }
}

CSSPropertyID CSSProperty::resolveDirectionAwareProperty(CSSPropertyID id, WritingMode writingMode)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalBlock: {
        static constexpr CSSPropertyID properties[2] = { CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalHorizontal, CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalVertical };
        return properties[static_cast<size_t>(mapAxisLogicalToPhysical(writingMode, LogicalBoxAxis::Block))];
    }
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalInline: {
        static constexpr CSSPropertyID properties[2] = { CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalHorizontal, CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalVertical };
        return properties[static_cast<size_t>(mapAxisLogicalToPhysical(writingMode, LogicalBoxAxis::Inline))];
    }
    default:
        return id;
    }
}

CSSPropertyID CSSProperty::unresolvePhysicalProperty(CSSPropertyID id, WritingMode writingMode)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalHorizontal: {
        static constexpr CSSPropertyID properties[2] = { CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalInline, CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalBlock };
        return properties[static_cast<size_t>(mapAxisPhysicalToLogical(writingMode, BoxAxis::Horizontal))];
    }
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalVertical: {
        static constexpr CSSPropertyID properties[2] = { CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalInline, CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalBlock };
        return properties[static_cast<size_t>(mapAxisPhysicalToLogical(writingMode, BoxAxis::Vertical))];
    }
    default:
        return id;
    }
}

bool CSSProperty::isDescriptorOnly(CSSPropertyID id)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyFirstTestDescriptorForFirstDescriptor:
    case CSSPropertyID::CSSPropertyFirstTestDescriptorForSecondDescriptor:
        return true;
    default:
        return false;
    }
}

bool CSSProperty::animationUsesNonAdditiveOrCumulativeInterpolation(CSSPropertyID id)
{
    switch (id) {
        return true;
    default:
        return false;
    }
}

bool CSSProperty::animationUsesNonNormalizedDiscreteInterpolation(CSSPropertyID id)
{
    switch (id) {
        return true;
    default:
        return false;
    }
}

bool CSSProperty::animationIsAccelerated(CSSPropertyID id, [[maybe_unused]] const Settings& settings)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyTestAnimationWrapperAccelerationAlways:
        return true;
    default:
        return false;
    }
}

std::span<const CSSPropertyID> CSSProperty::allAcceleratedAnimationProperties([[maybe_unused]] const Settings& settings)
{
    static constexpr std::array propertiesExcludingThreadedOnly {
        CSSPropertyID::CSSPropertyTestAnimationWrapperAccelerationAlways,
    };
    return std::span<const CSSPropertyID> { propertiesExcludingThreadedOnly };
}

CSSPropertySettings::CSSPropertySettings(const Settings& settings)
    : cssDescriptorEnabled { settings.cssDescriptorEnabled() }
    , cssSettingsOneEnabled { settings.cssSettingsOneEnabled() }
{
}

bool operator==(const CSSPropertySettings& a, const CSSPropertySettings& b)
{
    return a.cssDescriptorEnabled == b.cssDescriptorEnabled
        && a.cssSettingsOneEnabled == b.cssSettingsOneEnabled;
}

void add(Hasher& hasher, const CSSPropertySettings& settings)
{
    uint64_t bits = settings.cssDescriptorEnabled << 0
        | settings.cssSettingsOneEnabled << 1;
    add(hasher, bits);
}


TextStream& operator<<(TextStream& stream, CSSPropertyID property)
{
    return stream << nameLiteral(property);
}

} // namespace WebCore

WTF_ALLOW_UNSAFE_BUFFER_USAGE_END
IGNORE_WARNINGS_END
