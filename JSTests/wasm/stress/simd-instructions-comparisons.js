//@ requireOptions("--useWasmSIMD=1")
//@ skip if !$isSIMDPlatform
import { instantiate } from "../wabt-wrapper.js"
import * as assert from "../assert.js"

const verbose = false;

// Table-driven test data for SIMD comparison instructions
// Each entry: [instruction, input0, input1, expected_output]
const comparisonTests = [
    // i8x16.eq tests
    [
        "i8x16.eq",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
    ],
    [
        "i8x16.eq",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        "(v128.const i8x16 0x00 0x02 0x7F 0x81 0xFF 0x80 0x03 0x02 0x05 0x04 0x07 0x06 0x09 0x08 0x0B 0x0A)",
        [0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
    ],
    [
        "i8x16.eq",
        "(v128.const i8x16 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00)",
        "(v128.const i8x16 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF)",
        [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
    ],

    // i8x16.ne tests
    [
        "i8x16.ne",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
    ],
    [
        "i8x16.ne",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        "(v128.const i8x16 0x00 0x02 0x7F 0x81 0xFF 0x80 0x03 0x02 0x05 0x04 0x07 0x06 0x09 0x08 0x0B 0x0A)",
        [0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
    ],

    // i8x16.lt_s tests (signed less than)
    [
        "i8x16.lt_s",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        "(v128.const i8x16 0x01 0x02 0x80 0x7F 0x00 0x82 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B 0x0C)",
        [0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
    ],

    // i8x16.lt_u tests (unsigned less than)
    [
        "i8x16.lt_u",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        "(v128.const i8x16 0x01 0x02 0x80 0x81 0x00 0x82 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B 0x0C)",
        [0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
    ],

    // i8x16.gt_s tests (signed greater than)
    [
        "i8x16.gt_s",
        "(v128.const i8x16 0x01 0x02 0x80 0x7F 0x00 0x82 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B 0x0C)",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        [0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
    ],

    // i8x16.gt_u tests (unsigned greater than)
    [
        "i8x16.gt_u",
        "(v128.const i8x16 0x01 0x02 0x80 0x81 0x00 0x82 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B 0x0C)",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        [0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
    ],

    // i8x16.le_s tests (signed less than or equal)
    [
        "i8x16.le_s",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
    ],

    // i8x16.le_u tests (unsigned less than or equal)
    [
        "i8x16.le_u",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
    ],

    // i8x16.ge_s tests (signed greater than or equal)
    [
        "i8x16.ge_s",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
    ],

    // i8x16.ge_u tests (unsigned greater than or equal)
    [
        "i8x16.ge_u",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        "(v128.const i8x16 0x00 0x01 0x7F 0x80 0xFF 0x81 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B)",
        [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
    ],

    // i16x8.eq tests
    [
        "i16x8.eq",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        [0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF] // All equal
    ],
    [
        "i16x8.eq",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        "(v128.const i16x8 0x0001 0x0000 0x8000 0x7FFF 0x8001 0xFFFF 0x0003 0x0002)",
        [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000] // All different
    ],

    // i16x8.ne tests
    [
        "i16x8.ne",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000] // All equal, so ne = false
    ],
    [
        "i16x8.ne",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        "(v128.const i16x8 0x0001 0x0000 0x8000 0x7FFF 0x8001 0xFFFF 0x0003 0x0002)",
        [0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF] // All different
    ],

    // i16x8.lt_s tests (signed less than)
    [
        "i16x8.lt_s",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        "(v128.const i16x8 0x0001 0x0002 0x8000 0x7FFF 0x0000 0x8002 0x0003 0x0004)",
        [0xFFFF, 0xFFFF, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF] // 0<1, 1<2, 0x7FFF>0x8000(signed), 0x8000<0x7FFF(signed), -1<0, etc.
    ],
    [
        "i16x8.lt_s",
        "(v128.const i16x8 0x0001 0x0000 0x7FFF 0x8001 0xFFFF 0x0002 0x8000 0x0005)",
        "(v128.const i16x8 0x0000 0x0001 0x8000 0x8000 0x0000 0x0001 0x7FFF 0x0004)",
        [0x0000, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0x0000, 0xFFFF, 0x0000] // Mixed results: false, true, false, false, true, false, true, false
    ],

    // i16x8.lt_u tests (unsigned less than)
    [
        "i16x8.lt_u",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        "(v128.const i16x8 0x0001 0x0002 0x8000 0x8001 0x0000 0x8002 0x0003 0x0004)",
        [0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF] // All unsigned comparisons
    ],
    [
        "i16x8.lt_u",
        "(v128.const i16x8 0x0001 0x0000 0x8000 0x7FFF 0x0002 0xFFFF 0x8001 0x0005)",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0x0001 0x0000 0x8002 0x0004)",
        [0x0000, 0xFFFF, 0x0000, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0x0000] // Mixed results: false, true, false, true, false, false, true, false
    ],

    // i16x8.gt_s tests (signed greater than)
    [
        "i16x8.gt_s",
        "(v128.const i16x8 0x0001 0x0002 0x8000 0x7FFF 0x0000 0x8002 0x0003 0x0004)",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        [0xFFFF, 0xFFFF, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF] // Reverse of lt_s test
    ],
    [
        "i16x8.gt_s",
        "(v128.const i16x8 0x0000 0x0001 0x8000 0x8000 0x0000 0x0001 0x7FFF 0x0004)",
        "(v128.const i16x8 0x0001 0x0000 0x7FFF 0x8001 0xFFFF 0x0002 0x8000 0x0005)",
        [0x0000, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0x0000, 0xFFFF, 0x0000] // Mixed results: false, true, false, false, true, false, true, false
    ],

    // i16x8.gt_u tests (unsigned greater than)
    [
        "i16x8.gt_u",
        "(v128.const i16x8 0x0001 0x0002 0x8000 0x8001 0x0000 0x8002 0x0003 0x0004)",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        [0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF] // Reverse of lt_u test
    ],
    [
        "i16x8.gt_u",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0x0001 0x0000 0x8002 0x0004)",
        "(v128.const i16x8 0x0001 0x0000 0x8000 0x7FFF 0x0002 0xFFFF 0x8001 0x0005)",
        [0x0000, 0xFFFF, 0x0000, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0x0000] // Mixed results: false, true, false, true, false, false, true, false
    ],

    // i16x8.le_s tests (signed less than or equal)
    [
        "i16x8.le_s",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        [0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF] // All equal
    ],

    // i16x8.le_u tests (unsigned less than or equal)
    [
        "i16x8.le_u",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        [0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF] // All equal
    ],

    // i16x8.ge_s tests (signed greater than or equal)
    [
        "i16x8.ge_s",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        [0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF] // All equal
    ],

    // i16x8.ge_u tests (unsigned greater than or equal)
    [
        "i16x8.ge_u",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        "(v128.const i16x8 0x0000 0x0001 0x7FFF 0x8000 0xFFFF 0x8001 0x0002 0x0003)",
        [0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF] // All equal
    ],

    // i32x4.eq tests
    [
        "i32x4.eq",
        "(v128.const i32x4 0x12345678 0x9ABCDEF0 0x11111111 0x22222222)",
        "(v128.const i32x4 0x12345678 0x9ABCDEF0 0x11111111 0x22222222)",
        [0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF] // All equal
    ],
    [
        "i32x4.eq",
        "(v128.const i32x4 0x12345678 0x9ABCDEF0 0x11111111 0x22222222)",
        "(v128.const i32x4 0x12345679 0x9ABCDEF0 0x11111110 0x22222222)",
        [0x00000000, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF] // Different, equal, different, equal
    ],

    // i32x4.ne tests
    [
        "i32x4.ne",
        "(v128.const i32x4 0x12345678 0x9ABCDEF0 0x11111111 0x22222222)",
        "(v128.const i32x4 0x12345678 0x9ABCDEF0 0x11111111 0x22222222)",
        [0x00000000, 0x00000000, 0x00000000, 0x00000000] // All equal, so ne = false
    ],
    [
        "i32x4.ne",
        "(v128.const i32x4 0x12345678 0x9ABCDEF0 0x11111111 0x22222222)",
        "(v128.const i32x4 0x12345679 0x9ABCDEF0 0x11111110 0x22222222)",
        [0xFFFFFFFF, 0x00000000, 0xFFFFFFFF, 0x00000000] // Different, equal, different, equal
    ],

    // i32x4.lt_s tests (signed less than)
    [
        "i32x4.lt_s",
        "(v128.const i32x4 0x00000000 0x7FFFFFFF 0x80000000 0xFFFFFFFF)",
        "(v128.const i32x4 0x00000001 0x80000000 0x7FFFFFFF 0x00000000)",
        [0xFFFFFFFF, 0x00000000, 0xFFFFFFFF, 0xFFFFFFFF] // 0<1, 0x7FFFFFFF>0x80000000(signed), 0x80000000<0x7FFFFFFF(signed), -1<0
    ],
    [
        "i32x4.lt_s",
        "(v128.const i32x4 0x00000001 0x80000000 0x00000000 0x7FFFFFFF)",
        "(v128.const i32x4 0x00000000 0x7FFFFFFF 0xFFFFFFFF 0x80000000)",
        [0x00000000, 0xFFFFFFFF, 0x00000000, 0x00000000] // Mixed results: false, true, false, false
    ],

    // i32x4.lt_u tests (unsigned less than)
    [
        "i32x4.lt_u",
        "(v128.const i32x4 0x00000000 0x7FFFFFFF 0x80000000 0xFFFFFFFF)",
        "(v128.const i32x4 0x00000001 0x80000000 0x80000001 0x00000000)",
        [0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000] // All unsigned comparisons
    ],
    [
        "i32x4.lt_u",
        "(v128.const i32x4 0x00000001 0x80000000 0x00000000 0x7FFFFFFF)",
        "(v128.const i32x4 0x00000000 0x7FFFFFFF 0xFFFFFFFF 0x80000000)",
        [0x00000000, 0x00000000, 0xFFFFFFFF, 0xFFFFFFFF] // Mixed results: false, false, true, true
    ],

    // i32x4.gt_s tests (signed greater than)
    [
        "i32x4.gt_s",
        "(v128.const i32x4 0x00000001 0x80000000 0x7FFFFFFF 0x00000000)",
        "(v128.const i32x4 0x00000000 0x7FFFFFFF 0x80000000 0xFFFFFFFF)",
        [0xFFFFFFFF, 0x00000000, 0xFFFFFFFF, 0xFFFFFFFF] // Reverse of lt_s test
    ],
    [
        "i32x4.gt_s",
        "(v128.const i32x4 0x00000000 0x7FFFFFFF 0xFFFFFFFF 0x80000000)",
        "(v128.const i32x4 0x00000001 0x80000000 0x00000000 0x7FFFFFFF)",
        [0x00000000, 0xFFFFFFFF, 0x00000000, 0x00000000] // Mixed results: false, true, false, false
    ],

    // i32x4.gt_u tests (unsigned greater than)
    [
        "i32x4.gt_u",
        "(v128.const i32x4 0x00000001 0x80000000 0x80000001 0x00000000)",
        "(v128.const i32x4 0x00000000 0x7FFFFFFF 0x80000000 0xFFFFFFFF)",
        [0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000] // Reverse of lt_u test
    ],
    [
        "i32x4.gt_u",
        "(v128.const i32x4 0x00000000 0x7FFFFFFF 0xFFFFFFFF 0x80000000)",
        "(v128.const i32x4 0x00000001 0x80000000 0x00000000 0x7FFFFFFF)",
        [0x00000000, 0x00000000, 0xFFFFFFFF, 0xFFFFFFFF] // Mixed results: false, false, true, true
    ],

    // i32x4.le_s tests (signed less than or equal)
    [
        "i32x4.le_s",
        "(v128.const i32x4 0x12345678 0x9ABCDEF0 0x11111111 0x22222222)",
        "(v128.const i32x4 0x12345678 0x9ABCDEF0 0x11111111 0x22222222)",
        [0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF] // All equal
    ],

    // i32x4.le_u tests (unsigned less than or equal)
    [
        "i32x4.le_u",
        "(v128.const i32x4 0x12345678 0x9ABCDEF0 0x11111111 0x22222222)",
        "(v128.const i32x4 0x12345678 0x9ABCDEF0 0x11111111 0x22222222)",
        [0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF] // All equal
    ],

    // i32x4.ge_s tests (signed greater than or equal)
    [
        "i32x4.ge_s",
        "(v128.const i32x4 0x12345678 0x9ABCDEF0 0x11111111 0x22222222)",
        "(v128.const i32x4 0x12345678 0x9ABCDEF0 0x11111111 0x22222222)",
        [0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF] // All equal
    ],

    // i32x4.ge_u tests (unsigned greater than or equal)
    [
        "i32x4.ge_u",
        "(v128.const i32x4 0x12345678 0x9ABCDEF0 0x11111111 0x22222222)",
        "(v128.const i32x4 0x12345678 0x9ABCDEF0 0x11111111 0x22222222)",
        [0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF] // All equal
    ],

    // f32x4.eq tests
    [
        "f32x4.eq",
        "(v128.const f32x4 1.5 -2.25 3.75 -4.125)",
        "(v128.const f32x4 1.5 -2.25 3.75 -4.125)",
        [0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF] // All equal
    ],
    [
        "f32x4.eq",
        "(v128.const f32x4 1.5 -2.25 3.75 -4.125)",
        "(v128.const f32x4 1.6 -2.25 3.76 -4.125)",
        [0x00000000, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF] // Different, equal, different, equal
    ],

    // f32x4.ne tests
    [
        "f32x4.ne",
        "(v128.const f32x4 1.5 -2.25 3.75 -4.125)",
        "(v128.const f32x4 1.5 -2.25 3.75 -4.125)",
        [0x00000000, 0x00000000, 0x00000000, 0x00000000] // All equal, so ne = false
    ],
    [
        "f32x4.ne",
        "(v128.const f32x4 1.5 -2.25 3.75 -4.125)",
        "(v128.const f32x4 1.6 -2.25 3.76 -4.125)",
        [0xFFFFFFFF, 0x00000000, 0xFFFFFFFF, 0x00000000] // Different, equal, different, equal
    ],

    // f32x4.lt tests
    [
        "f32x4.lt",
        "(v128.const f32x4 1.0 -2.0 3.0 -4.0)",
        "(v128.const f32x4 2.0 -1.0 4.0 -3.0)",
        [0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF] // 1.0<2.0, -2.0<-1.0, 3.0<4.0, -4.0<-3.0
    ],

    // f32x4.gt tests
    [
        "f32x4.gt",
        "(v128.const f32x4 2.0 -1.0 4.0 -3.0)",
        "(v128.const f32x4 1.0 -2.0 3.0 -4.0)",
        [0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF] // 2.0>1.0, -1.0>-2.0, 4.0>3.0, -3.0>-4.0
    ],

    // f32x4.le tests
    [
        "f32x4.le",
        "(v128.const f32x4 1.5 -2.25 3.75 -4.125)",
        "(v128.const f32x4 1.5 -2.25 3.75 -4.125)",
        [0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF] // All equal
    ],

    // f32x4.ge tests
    [
        "f32x4.ge",
        "(v128.const f32x4 1.5 -2.25 3.75 -4.125)",
        "(v128.const f32x4 1.5 -2.25 3.75 -4.125)",
        [0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF] // All equal
    ],

    // f64x2.eq tests
    [
        "f64x2.eq",
        "(v128.const f64x2 1.25 -3.5)",
        "(v128.const f64x2 1.25 -3.5)",
        [0xFFFFFFFFFFFFFFFFn, 0xFFFFFFFFFFFFFFFFn] // Both equal
    ],
    [
        "f64x2.eq",
        "(v128.const f64x2 1.25 -3.5)",
        "(v128.const f64x2 1.26 -3.5)",
        [0x0000000000000000n, 0xFFFFFFFFFFFFFFFFn] // Different, equal
    ],

    // f64x2.ne tests
    [
        "f64x2.ne",
        "(v128.const f64x2 1.25 -3.5)",
        "(v128.const f64x2 1.25 -3.5)",
        [0x0000000000000000n, 0x0000000000000000n] // Both equal, so ne = false
    ],
    [
        "f64x2.ne",
        "(v128.const f64x2 1.25 -3.5)",
        "(v128.const f64x2 1.26 -3.5)",
        [0xFFFFFFFFFFFFFFFFn, 0x0000000000000000n] // Different, equal
    ],

    // f64x2.lt tests
    [
        "f64x2.lt",
        "(v128.const f64x2 1.0 -2.0)",
        "(v128.const f64x2 2.0 -1.0)",
        [0xFFFFFFFFFFFFFFFFn, 0xFFFFFFFFFFFFFFFFn] // 1.0<2.0, -2.0<-1.0
    ],

    // f64x2.gt tests
    [
        "f64x2.gt",
        "(v128.const f64x2 2.0 -1.0)",
        "(v128.const f64x2 1.0 -2.0)",
        [0xFFFFFFFFFFFFFFFFn, 0xFFFFFFFFFFFFFFFFn] // 2.0>1.0, -1.0>-2.0
    ],

    // f64x2.le tests
    [
        "f64x2.le",
        "(v128.const f64x2 1.25 -3.5)",
        "(v128.const f64x2 1.25 -3.5)",
        [0xFFFFFFFFFFFFFFFFn, 0xFFFFFFFFFFFFFFFFn] // Both equal
    ],

    // f64x2.ge tests
    [
        "f64x2.ge",
        "(v128.const f64x2 1.25 -3.5)",
        "(v128.const f64x2 1.25 -3.5)",
        [0xFFFFFFFFFFFFFFFFn, 0xFFFFFFFFFFFFFFFFn] // Both equal
    ]
];

// Generate WebAssembly module with test functions
function generateWat() {
    let wat = `
(module
    (memory (export "memory") 1)
    
    ;; Helper function to store v128 result to memory
    (func (export "store_result") (param $addr i32) (param $value v128)
        (v128.store (local.get $addr) (local.get $value))
    )
`;

    // Generate a test function for each comparison test
    comparisonTests.forEach((test, index) => {
        const [instruction, input0, input1, expected] = test;
        wat += `
    (func (export "test_${index}") (param $addr i32)
        (v128.store (local.get $addr)
            (${instruction} ${input0} ${input1}))
    )
`;
    });

    wat += `
)
`;
    return wat;
}

async function test() {
    const wat = generateWat();
    const instance = await instantiate(wat, {}, { simd: true });
    const memory = instance.exports.memory;
    const buffer = memory.buffer;
    const u8 = new Uint8Array(buffer);
    const u16 = new Uint16Array(buffer);
    const u32 = new Uint32Array(buffer);
    const u64 = new BigUint64Array(buffer);

    function clearMemory() {
        u8.fill(0);
    }

    for (let i = 0; i < wasmTestLoopCount; ++i) {
        // Test each comparison instruction
        comparisonTests.forEach((test, testIndex) => {
            const [instruction, input0, input1, expected] = test;
            
            if (verbose)
                print(`Testing ${instruction} test ${testIndex}...`);
            
            clearMemory();
            
            // Call the test function
            const testFunc = instance.exports[`test_${testIndex}`];
            testFunc(0);
            
            // Verify the result using appropriate data type
            if (instruction.startsWith('i8x16.')) {
                // i8x16 instructions: verify as bytes
                for (let j = 0; j < 16; j++)
                    assert.eq(u8[j], expected[j]);
            } else if (instruction.startsWith('i16x8.')) {
                // i16x8 instructions: verify as 16-bit words
                for (let j = 0; j < 8; j++)
                    assert.eq(u16[j], expected[j]);
            } else if (instruction.startsWith('i32x4.') || instruction.startsWith('f32x4.')) {
                // i32x4 and f32x4 instructions: verify as 32-bit words
                for (let j = 0; j < 4; j++)
                    assert.eq(u32[j], expected[j]);
            } else if (instruction.startsWith('f64x2.')) {
                // f64x2 instructions: verify as 64-bit words
                for (let j = 0; j < 2; j++)
                    assert.eq(u64[j], expected[j]);
            }
            
            if (verbose)
                print(`âœ“ ${instruction} test ${testIndex} passed`);
        });
    }
    
    if (verbose)
        print(`All ${comparisonTests.length} SIMD comparison tests passed!`);
}

await assert.asyncTest(test())
